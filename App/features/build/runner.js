define(function(require){
    var path = requireNode('path'),
        WorkIndicator = require('infrastructure/workIndicator'),
        fileSystem = require('infrastructure/fileSystem'),
        dialog = require('plugins/dialog'),
        system = require('durandal/system'),
        selectedGame = require('features/projectSelector/index');

    function cleanDirs(context) {
        return system.defer(function(task) {

            // Can't blindly clean these directories, beccause there are
            // checked-in, non-generated files mixed in with the generated ones.

            // These have Music, Vignette, etc. files
            //fileSystem.clearDirectory(context.dataOutputDirectory);

            // These have non-generate .cs (C#) files
            //fileSystem.clearDirectory(context.codeOutputDirectory);
            //fileSystem.clearDirectory(context.editorOutputDirectory);

            // This contains Unity .meta file(s).
            //fileSystem.clearDirectory(context.localizationOutputDirectory);

            // These should only contain generated data, but apparently they don't.
            // And this causes issues on some systems?
            // Commenting out.
            //fileSystem.clearDirectory(context.dataOutputDirectory + "/scripts");
            //fileSystem.clearDirectory(context.internalDocOutputDirectory);

            //fileSystem.clearDirectory(context.reportsOutputDirectory);

            if(fileSystem.exists(context.doneFile)) {
                fileSystem.remove(context.doneFile);
            }

            // These directories / files are autogenerated (not checked in).
            // If they don't currently exist, create them.
            if( ! fileSystem.exists(context.internalDocOutputDirectory)) {
                fileSystem.makeDirectory(context.internalDocOutputDirectory);
            }

            if( ! fileSystem.exists(context.reportsOutputDirectory)) {
                fileSystem.makeDirectory(context.reportsOutputDirectory);
            }

            task.resolve();
        });
    }

    function runner(id, context, data1, data2, data3){
        return function(){
            return system.acquire(id).then(function(task){
                return task.run(context, data1, data2, data3);
            });
        }
    }

    function codeId(project, name){
        return 'features/build/' + project.build.targetPlatform + '/' + project.build.targetLanguage + '/' + name;
    }

    return {
        // This is the thing that actually does the build!
        run:function(project, mode){
            var indicator = new WorkIndicator();
            dialog.show(indicator);

            var localizationDupes = {};
            var localizationTable = {};
            var translationTable = {};
            var translationTableKeys = [];
            var completed = [];
            var context = {
                startTime: new Date().toLocaleString(),
                completed: completed,
                project:project,
                mode: mode,
                indicator:indicator,
                game: selectedGame.activeProject,
                dataOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.dataOutputDirectory),
                codeOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.codeOutputDirectory),
                editorOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.editorOutputDirectory),
                localizationOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.localizationOutputDirectory),
                translationOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.translationOutputDirectory),
                internalDocOutputDirectory:path.resolve(selectedGame.activeProject.dir, project.build.internalDocOutputDirectory),
                reportsOutputDirectory: path.join(path.resolve(selectedGame.activeProject.dir, project.build.internalDocOutputDirectory), 'Reports'),
                doneFile: path.join(path.resolve(selectedGame.activeProject.dir, project.build.internalDocOutputDirectory), 'buildDone.txt'),
                gameModel: {
                    entityModels:[],
                    scriptIndex:[]
                },
                getJsonSpacing:function(){
                    return this.mode == 'debug' ? 4 : undefined
                },
                addLocalizationEntry:function(id, text, notes, speaker) {
                    // If the text was undefined, treat it as empty.
                    if (text == undefined) {
                        text = '';
                    }
                    // If a localizationTable entry has been defined multiple times for different values...
                    if (localizationTable.hasOwnProperty(id) && localizationTable[id][1] != text) {
                        if (!localizationDupes[id]) {
                            localizationDupes[id] = [];
                            localizationDupes[id].push(localizationTable[id][1]);
                        }
                        localizationDupes[id].push(text);
                    }
                    localizationTable[id] = [id,text];

                    // The translationTable is basically a reverse lookup of the localizationTable,
                    // as the same text could be defined for multiple ids.
                    if (!translationTable[text]) {
                        translationTableKeys.push(text);
                        translationTable[text] = { 0: text, translations : [], speakers : [], notes : [], ids : [] };
                    }
                    if (speaker) {
                        translationTable[text].speakers.push(speaker);
                    }
                    if (notes) {
                        translationTable[text].notes.push(notes);
                    }
                    translationTable[text].ids.push(id);
                }

            };

            return cleanDirs(context)
                .then(runner('features/build/data/actors', context))
                .then(runner('features/build/data/props', context))
                .then(runner('features/build/data/storyEvents', context))
                .then(runner('features/build/data/scenes', context))
                .then(runner('features/build/data/scripts', context))
                .then(runner('features/build/data/gameModel', context))
                .then(runner('features/build/data/localization', context, localizationTable, translationTable, translationTableKeys))
                .then(runner('features/build/data/internalDoc', context, localizationDupes))
                .then(runner('features/build/data/generateAddlOutput', context, localizationDupes))
                .then(runner('features/build/data/achievements', context))
                .then(runner('features/build/data/quests', context))
                .then(runner('features/build/data/inventoryIds', context))
                .then(runner(codeId(project, 'actors'), context))
                .then(runner(codeId(project, 'storyEvents'), context))
                .then(runner(codeId(project, 'scenes'), context))
                .then(runner(codeId(project, 'scripts'), context))
                .then(runner(codeId(project, 'localizationGroups'), context))
                // There are 15 runners defined above, but
                // codeId(actors) and codeId(scenes) also calls generateRegistry(),
                // which separately appends to context.completed
                .then(runner('features/build/data/buildDone', context, 19 ))
                .then(function(){
                    // Try to wait for files to be written.
                    // Node doesn't offer a flush() command so there's no way
                    // to guess when the files will actually be committed to disk.
                    // This is a hacky method in hopes that Node will write in FIFO order
                    // and that the last file will be created only when all of the others are completed.
                    while (!fileSystem.exists(context.doneFile)) {
                        setTimeout(function() { }, 500);
                    }
                    // Here is where we close the build indicator.
                    dialog.close(indicator);

                    // BATCH MODE CHECK!
                    // In batch builds we want to shutdown after the build.
                    var myArgs = require('nw.gui').App.argv;
                    if(myArgs.indexOf('batchBuild') > -1)
                    {
                        // Shutdown at some point in the future giving lots of time
                        // for data to flush to disk! This is a problem as we don't
                        // know when all data has fully flushed to the HD.
                        setTimeout(function() {  window.close(true); }, 30000);
                    }
                });
        }
    };
});
